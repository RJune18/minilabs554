
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module Minilab1(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output	reg	     [6:0]		HEX0,
	output	reg	     [6:0]		HEX1,
	output	reg	     [6:0]		HEX2,
	output	reg	     [6:0]		HEX3,
	output	reg	     [6:0]		HEX4,
	output	reg	     [6:0]		HEX5,
	
	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW
);

localparam DATA_WIDTH = 8;
localparam N = 8;
localparam M = 8;

localparam FILL_LOAD_MEM = 2'd0;
localparam FILL_FILL_FIFO = 2'd1;
localparam AWAIT = 2'd2;
localparam DONE = 2'd3;

parameter HEX_0 = 7'b1000000;		// zero
parameter HEX_1 = 7'b1111001;		// one
parameter HEX_2 = 7'b0100100;		// two
parameter HEX_3 = 7'b0110000;		// three
parameter HEX_4 = 7'b0011001;		// four
parameter HEX_5 = 7'b0010010;		// five
parameter HEX_6 = 7'b0000010;		// six
parameter HEX_7 = 7'b1111000;		// seven
parameter HEX_8 = 7'b0000000;		// eight
parameter HEX_9 = 7'b0011000;		// nine
parameter HEX_10 = 7'b0001000;	// ten
parameter HEX_11 = 7'b0000011;	// eleven
parameter HEX_12 = 7'b1000110;	// twelve
parameter HEX_13 = 7'b0100001;	// thirteen
parameter HEX_14 = 7'b0000110;	// fourteen
parameter HEX_15 = 7'b0001110;	// fifteen
parameter OFF   = 7'b1111111;		// all off

//=======================================================
//  REG/WIRE declarations
//=======================================================

reg [1:0] state;
reg [$clog2(N+1)-1:0] N_counter;

wire rst_n;
wire mem_clk;
wire mmul_clk;

reg en_mmul;
wire [DATA_WIDTH*M-1:0] a;
reg  [M-1:0]a_valid;
wire [DATA_WIDTH-1:0] b;
reg b_valid;
wire [DATA_WIDTH*3*M-1:0] wide_c;
wire [DATA_WIDTH*3-1:0] c;

wire [DATA_WIDTH-1:0] word;

reg [31:0] address;
reg read;
wire [63:0] readdata;
reg [63:0] readdata_reg;
wire readdatavalid;

//=======================================================
//  Module instantiation
//=======================================================

mmul_fifo_wrapper mmul_fifo_wrapper_inst (
    .i_clk_wr_fifo(mem_clk),
    .i_clk_mmul(mmul_clk),
    .i_rst_n(rst_n),
    .i_en_mmul(en_mmul),
    .i_clr(),
    .i_a(a),
    .i_a_valid(a_valid),
    .o_a_full(),
    .i_b(b),
    .i_b_valid(b_valid),
    .o_b_full(),
    .o_c(wide_c)
);

mem_wrapper mem_wrapper_inst (
    .clk(mem_clk),
    .reset_n(rst_n),

    .address(address),
    .read(read),
    .readdata(readdata),
    .readdatavalid(readdatavalid),
    .waitrequest()
);

//=======================================================
//  Structural coding
//=======================================================

assign rst_n = KEY[0];
assign mem_clk = CLOCK_50;
assign mmul_clk = CLOCK2_50;

always @(posedge mem_clk or negedge rst_n) begin
    if (~rst_n) begin
        state <= FILL_LOAD_MEM;
        address <= 0;
        read <= 1;
    end
    else begin
        case(state)
	    FILL_LOAD_MEM: begin
                read <= 1'b0;
                if (address > DATA_WIDTH) begin
                    state <= AWAIT;
                end
                else if (readdatavalid) begin
                    state <= FILL_FILL_FIFO;
                    readdata_reg <= readdata;
                    N_counter <= 0;
                    if (address < DATA_WIDTH) begin
                        a_valid[address] <= 1'b1;
                    end
                    else begin
                        b_valid <= 1'b1;
                    end
                end
	    end	
            FILL_FILL_FIFO: begin
                if (N_counter >= N) begin
                    state <= FILL_LOAD_MEM;
                    address <= address + 1;
                    read <= 1'b1;
                    if (address < DATA_WIDTH) begin
                        a_valid[address] <= 1'b0;
                    end
                    else begin
                        b_valid <= 1'b0;
                    end
                end
                else begin
                    N_counter <= N_counter + 1;
                end
            end
	    AWAIT: begin
		if (1 /* TODO: expose done signal from mmult */) begin
		    state <= DONE;
                    en_mmul <= 1'b1;
	        end
	    end
	    DONE: begin
                en_mmul <= 1'b0;
	    end
	 endcase
    end
end

/* Multiplex the word to fill the FIFO */
assign word = readdata_reg[(N-1-N_counter)*8 +: 8];

assign b = word;
genvar i;
generate
    for (i = 0; i < M; i = i + 1) begin : gen_a_i
        assign a[i*DATA_WIDTH+:DATA_WIDTH] = word;
    end
endgenerate

/* Multiplex the cell to display from the column */
assign c = wide_c[SW[3:1]*3*DATA_WIDTH+:3*DATA_WIDTH];

/* 7 segment display logic */
always @(*) begin
  if (state == DONE & SW[0]) begin
    case(c[3:0])
      4'd0: HEX0 = HEX_0;
	   4'd1: HEX0 = HEX_1;
	   4'd2: HEX0 = HEX_2;
	   4'd3: HEX0 = HEX_3;
	   4'd4: HEX0 = HEX_4;
	   4'd5: HEX0 = HEX_5;
	   4'd6: HEX0 = HEX_6;
	   4'd7: HEX0 = HEX_7;
	   4'd8: HEX0 = HEX_8;
	   4'd9: HEX0 = HEX_9;
	   4'd10: HEX0 = HEX_10;
	   4'd11: HEX0 = HEX_11;
	   4'd12: HEX0 = HEX_12;
	   4'd13: HEX0 = HEX_13;
	   4'd14: HEX0 = HEX_14;
	   4'd15: HEX0 = HEX_15;
    endcase
  end
  else begin
    HEX0 = OFF;
  end
end

always @(*) begin
  if (state == DONE & SW[0]) begin
    case(c[7:4])
      4'd0: HEX1 = HEX_0;
	   4'd1: HEX1 = HEX_1;
	   4'd2: HEX1 = HEX_2;
	   4'd3: HEX1 = HEX_3;
	   4'd4: HEX1 = HEX_4;
	   4'd5: HEX1 = HEX_5;
	   4'd6: HEX1 = HEX_6;
	   4'd7: HEX1 = HEX_7;
	   4'd8: HEX1 = HEX_8;
	   4'd9: HEX1 = HEX_9;
	   4'd10: HEX1 = HEX_10;
	   4'd11: HEX1 = HEX_11;
	   4'd12: HEX1 = HEX_12;
	   4'd13: HEX1 = HEX_13;
	   4'd14: HEX1 = HEX_14;
	   4'd15: HEX1 = HEX_15;
    endcase
  end
  else begin
    HEX1 = OFF;
  end
end

always @(*) begin
  if (state == DONE & SW[0]) begin
    case(c[11:8])
      4'd0: HEX2 = HEX_0;
	   4'd1: HEX2 = HEX_1;
	   4'd2: HEX2 = HEX_2;
	   4'd3: HEX2 = HEX_3;
	   4'd4: HEX2 = HEX_4;
	   4'd5: HEX2 = HEX_5;
	   4'd6: HEX2 = HEX_6;
	   4'd7: HEX2 = HEX_7;
	   4'd8: HEX2 = HEX_8;
	   4'd9: HEX2 = HEX_9;
	   4'd10: HEX2 = HEX_10;
	   4'd11: HEX2 = HEX_11;
	   4'd12: HEX2 = HEX_12;
	   4'd13: HEX2 = HEX_13;
	   4'd14: HEX2 = HEX_14;
	   4'd15: HEX2 = HEX_15;
    endcase
  end
  else begin
    HEX2 = OFF;
  end
end

always @(*) begin
  if (state == DONE & SW[0]) begin
    case(c[15:12])
      4'd0: HEX3 = HEX_0;
	   4'd1: HEX3 = HEX_1;
	   4'd2: HEX3 = HEX_2;
	   4'd3: HEX3 = HEX_3;
	   4'd4: HEX3 = HEX_4;
	   4'd5: HEX3 = HEX_5;
	   4'd6: HEX3 = HEX_6;
	   4'd7: HEX3 = HEX_7;
	   4'd8: HEX3 = HEX_8;
	   4'd9: HEX3 = HEX_9;
	   4'd10: HEX3 = HEX_10;
	   4'd11: HEX3 = HEX_11;
	   4'd12: HEX3 = HEX_12;
	   4'd13: HEX3 = HEX_13;
	   4'd14: HEX3 = HEX_14;
	   4'd15: HEX3 = HEX_15;
    endcase
  end
  else begin
    HEX3 = OFF;
  end
end

always @(*) begin
  if (state == DONE & SW[0]) begin
    case(c[19:16])
      4'd0: HEX4 = HEX_0;
	   4'd1: HEX4 = HEX_1;
	   4'd2: HEX4 = HEX_2;
	   4'd3: HEX4 = HEX_3;
	   4'd4: HEX4 = HEX_4;
	   4'd5: HEX4 = HEX_5;
	   4'd6: HEX4 = HEX_6;
	   4'd7: HEX4 = HEX_7;
	   4'd8: HEX4 = HEX_8;
	   4'd9: HEX4 = HEX_9;
	   4'd10: HEX4 = HEX_10;
	   4'd11: HEX4 = HEX_11;
	   4'd12: HEX4 = HEX_12;
	   4'd13: HEX4 = HEX_13;
	   4'd14: HEX4 = HEX_14;
	   4'd15: HEX4 = HEX_15;
    endcase
  end
  else begin
    HEX4 = OFF;
  end
end

always @(*) begin
  if (state == DONE & SW[0]) begin
    case(c[23:20])
      4'd0: HEX5 = HEX_0;
	   4'd1: HEX5 = HEX_1;
	   4'd2: HEX5 = HEX_2;
	   4'd3: HEX5 = HEX_3;
	   4'd4: HEX5 = HEX_4;
	   4'd5: HEX5 = HEX_5;
	   4'd6: HEX5 = HEX_6;
	   4'd7: HEX5 = HEX_7;
	   4'd8: HEX5 = HEX_8;
	   4'd9: HEX5 = HEX_9;
	   4'd10: HEX5 = HEX_10;
	   4'd11: HEX5 = HEX_11;
	   4'd12: HEX5 = HEX_12;
	   4'd13: HEX5 = HEX_13;
	   4'd14: HEX5 = HEX_14;
	   4'd15: HEX5 = HEX_15;
    endcase
  end
  else begin
    HEX5 = OFF;
  end
end

assign LEDR = {{8{1'b0}}, state};

endmodule
